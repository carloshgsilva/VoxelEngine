#include "Common.frag"

PUSH(
    int ReservoirA0RID;
    int ReservoirA1RID;
    int ReservoirA2RID;
    int ReservoirA3RID;
    int ReservoirB0RID;
    int ReservoirB1RID;
    int ReservoirB2RID;
    int ReservoirB3RID;
    int GBufferRID;
    int _ViewBufferRID;
    int TLASRID;
    int VoxInstancesRID;
    int SampleSize;
)

#define IMPORT
#include "View.frag"
#include "Light.frag"
#include "BRDF.frag"
#include "Reservoir.frag"

const vec2 OFFSETS[64] = {
    vec2(0.5000, 0.3333),
    vec2(0.2500, 0.6667),
    vec2(0.7500, 0.1111),
    vec2(0.1250, 0.4444),
    vec2(0.6250, 0.7778),
    vec2(0.3750, 0.2222),
    vec2(0.8750, 0.5556),
    vec2(0.0625, 0.8889),
    vec2(0.5625, 0.0370),
    vec2(0.3125, 0.3704),
    vec2(0.8125, 0.7037),
    vec2(0.1875, 0.1481),
    vec2(0.6875, 0.4815),
    vec2(0.4375, 0.8148),
    vec2(0.9375, 0.2593),
    vec2(0.0313, 0.5926),
    vec2(0.5313, 0.9259),
    vec2(0.2813, 0.0741),
    vec2(0.7813, 0.4074),
    vec2(0.1563, 0.7407),
    vec2(0.6563, 0.1852),
    vec2(0.4063, 0.5185),
    vec2(0.9063, 0.8519),
    vec2(0.0938, 0.2963),
    vec2(0.5938, 0.6296),
    vec2(0.3438, 0.9630),
    vec2(0.8438, 0.0123),
    vec2(0.2188, 0.3457),
    vec2(0.7188, 0.6790),
    vec2(0.4688, 0.1235),
    vec2(0.9688, 0.4568),
    vec2(0.0156, 0.7901),
    vec2(0.5156, 0.2346),
    vec2(0.2656, 0.5679),
    vec2(0.7656, 0.9012),
    vec2(0.1406, 0.0494),
    vec2(0.6406, 0.3827),
    vec2(0.3906, 0.7160),
    vec2(0.8906, 0.1605),
    vec2(0.0781, 0.4938),
    vec2(0.5781, 0.8272),
    vec2(0.3281, 0.2716),
    vec2(0.8281, 0.6049),
    vec2(0.2031, 0.9383),
    vec2(0.7031, 0.0864),
    vec2(0.4531, 0.4198),
    vec2(0.9531, 0.7531),
    vec2(0.0469, 0.1975),
    vec2(0.5469, 0.5309),
    vec2(0.2969, 0.8642),
    vec2(0.7969, 0.3086),
    vec2(0.1719, 0.6420),
    vec2(0.6719, 0.9753),
    vec2(0.4219, 0.0247),
    vec2(0.9219, 0.3580),
    vec2(0.1094, 0.6914),
    vec2(0.6094, 0.1358),
    vec2(0.3594, 0.4691),
    vec2(0.8594, 0.8025),
    vec2(0.2344, 0.2469),
    vec2(0.7344, 0.5802),
    vec2(0.4844, 0.9136),
    vec2(0.9844, 0.0617),
    vec2(0.0078, 0.3951),
};
struct Sampler {
    ivec2 pixel;
    int frame;
    int depth;
};

void InitSampler(inout Sampler samp, ivec2 pixel, int frame) {
    samp.pixel = pixel;
    samp.frame = frame;
    samp.depth = 0;
}
#define BLUE_NOISE (Sampler2D[ViewBuffer[_ViewBufferRID].BlueNoiseRID])
vec4 SampleNoise(inout Sampler samp) {
    vec2 res = textureSize(BLUE_NOISE, 0);
    samp.depth++;
    return texelFetch(BLUE_NOISE, (samp.pixel+ivec2(OFFSETS[(samp.frame+samp.depth)%64]*512.0))%512, 0);
}

COMPUTE(8, 8, 1)
void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    vec2 uv = vec2(pixel+GetJitter())*GetiRes();
    vec3 camO = GetCameraPosition();
    vec3 camD = UVToRayDir(uv);

    uvec4 gbuffer = GBufferFetch(GBufferRID, pixel);
    if(GBufferGetVisibility(gbuffer) == 0u) {
        return;
    }
    float t = GBufferGetDepth(gbuffer);
    vec3 n = GBufferGetNormal(gbuffer);
    
    GISample s;
    s.xv = camO + camD * t + n*EPS*10.0;
    s.nv = n;

    Sampler samp;
    InitSampler(samp, pixel, GetFrame()%64);

    Reservoir spatialReservoir;
    ReservoirLoad(ReservoirB0RID, ReservoirB1RID, ReservoirB2RID, ReservoirB3RID, pixel, spatialReservoir);

    float radius = 1.0;
    // for (float ang = (GetFrame()%4)*3; radius <= float(SampleSize); ang += GOLDEN_ANGLE) {
    //     radius += 1.0;

    //     ivec2 nPixel = pixel + ivec2(vec2(cos(ang), sin(ang)) * radius * 32.0 / float(SampleSize));

    //     // geometry validation
    //     vec2 nUV = nPixel*GetiRes();
    //     if(clamp(nUV, vec2(0), vec2(1)) != nUV) {
    //         continue;
    //     }
    //     uvec4 nGBuffer = GBufferFetch(GBufferRID, nPixel);
    //     float nDepth = GBufferGetDepth(nGBuffer);
    //     vec3 nPos = UVDepthToWorld(nUV, nDepth);
    //     float planeDist = abs(dot(nPos - s.xv, n));
    //     vec3 nNormal = GBufferGetNormal(nGBuffer);
    //     if(planeDist > max(0.0005*t, 0.05) || dot(nNormal, n) < 0.5) {
    //         continue;
    //     }

    //     Reservoir temporalReservoir;
    //     ReservoirLoad(ReservoirB0RID, ReservoirB1RID, ReservoirB2RID, ReservoirB3RID, nPixel, temporalReservoir);

    //     float jacobian = 1.0;
    //     float pHat = length(temporalReservoir.s.radiance) / jacobian;
    //     // ReservoirClamp(spatialReservoir, temporalReservoir.M, 300.0);
    //     ReservoirMerge(spatialReservoir, temporalReservoir, pHat, SampleNoise(samp).x);
    // }

    // if(SampleSize == 5) { // visibiliy validation (only on last spatial pass, introduces little bias)
    //     float l = length(spatialReservoir.s.xs - s.xv);
    //     vec3 dir = normalize(spatialReservoir.s.xs - s.xv);
    //     if(spatialReservoir.M > 0 && TraceShadowRay(s.xv + n*EPS*10.0, dir, l-EPS*100.0)) {
    //         ReservoirClear(spatialReservoir);
    //     }
    // }

    // {
    //     float den = spatialReservoir.M * (length(spatialReservoir.s.radiance));
    //     if(den > 0.0 && isnan(spatialReservoir.w) == false) {
    //         spatialReservoir.W = spatialReservoir.w / den;
    //     } else {
    //         #if 0 // resampling fail heat map
    //             spatialReservoir.W = 1.0;
    //             spatialReservoir.s.radiance = vec3(1,0,0);
    //         #else
    //             spatialReservoir.W = 0.0;
    //         #endif
    //     }
    // }
    
    ReservoirStore(ReservoirA0RID, ReservoirA1RID, ReservoirA2RID, ReservoirA3RID, pixel, spatialReservoir);
}