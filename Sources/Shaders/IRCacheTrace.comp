#include "Common.frag"

PUSH(
    int ColorTextureRID;
    int GBufferRID;
    int _ViewBufferRID;
    int TLASRID;
    int VoxInstancesRID;
    int RadianceCacheRID;
)

#define IMPORT
#include "Reservoir.frag"
#include "PathTrace.frag"

#define CACHE_MAX_CANDIDATES 8
BINDING_BUFFER_RW(Cache,
    vec4 at[65536];
    uint hash[65536];
    uint age[65536];
    uint condidates_count[65536];
    Reservoir condidates[65536][CACHE_MAX_CANDIDATES];
)

float uint2float(uint x) {
    return float(x)/float(0xFFFFFFFF);
}

bool GetCellIdx(vec3 pos, inout uint idx) {
    vec3 pDiff = abs(pos-GetCameraPosition());
    float dist = max(max(pDiff.x, pDiff.y), pDiff.z);

    float SCALE = 4.0 / max(floor(log(dist)), 0.5);
    uvec3 coord = uvec3(abs(pos-EPS)*SCALE);
    uvec3 id = pcg3d(coord^floatBitsToUint(SCALE));
    idx = id.x&0xFFFF;
    uint hash = id.z;

    // try to find cell
    for(int i = 0; i < 8; i++) {
        uint expected_hash = Cache[RadianceCacheRID].hash[idx+i];
        if(expected_hash == hash) {
            idx += i;
            return true;
        }
    }

    // alloc not found cell
    for(int i = 0; i < 8; i++) {
        if(atomicCompSwap(Cache[RadianceCacheRID].hash[idx+i], 0, hash) == 0) {
            idx += i;
            return true;
        }
    }

    return false;
}

COMPUTE(8, 8, 1)
void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    
    uvec4 gbuffer = GBufferFetch(GBufferRID, pixel);
    if(GBufferGetVisibility(gbuffer) == 0u) {
        return;
    }
    float t = GBufferGetDepth(gbuffer);
    vec3 n = GBufferGetNormal(gbuffer);
    
    vec2 uv = vec2(pixel+GetJitter())*GetiRes();
    vec3 o = GetCameraPosition();
    vec3 d = UVToRayDir(uv);
    
    vec3 pos = o + d*t;
    vec3 acc = vec3(0);
    uint idx = 0;
    if(GetCellIdx(pos, idx)) {
        Cache[RadianceCacheRID].age[idx] = 0;
        vec4 v = Cache[RadianceCacheRID].at[idx];
        if(v.w > 0.001) {
            acc = vec3(v.xyz/v.w);
        }

        if(pixel.x % 8 == 0 && pixel.y % 8 == 0) {
            Sampler samp;
            InitSampler(samp, pixel, GetFrame()%64);
            PathTraceState state;
            InitPathTraceState(state, pos, SampleUniformHemisphere(n, SampleNoise(samp).xy));
            bool hit = PathTraceProceed(state, samp);

            uint bounceIdx = 0;
            if(hit && GetCellIdx(state.o, bounceIdx)) {
                vec4 v = Cache[RadianceCacheRID].at[bounceIdx];
                Cache[RadianceCacheRID].age[bounceIdx] = 0;
                if(v.w > 0.001) {
                    state.acc += v.xyz/v.w;
                }
            }
           
            atomicAdd(Cache[RadianceCacheRID].at[idx].x, state.acc.x);
            atomicAdd(Cache[RadianceCacheRID].at[idx].y, state.acc.y);
            atomicAdd(Cache[RadianceCacheRID].at[idx].z, state.acc.z);
            atomicAdd(Cache[RadianceCacheRID].at[idx].w, 1.0);
        }
    } else {
        acc = vec3(1,0,0);
    }
    // acc = RandomColor(idx);
    
    imageStore(Image2DW[ColorTextureRID], pixel, vec4(acc,1));
}