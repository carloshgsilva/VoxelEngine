#include "Common.frag"

PUSH(
    int ColorTextureRID;
    int GBufferRID;
    int _ViewBufferRID;
    int TLASRID;
    int VoxInstancesRID;
    int RadianceCacheRID;
)

#define IMPORT
#include "Reservoir.frag"
#include "PathTrace.frag"

#define CACHE_MAX_CANDIDATES 8
BINDING_BUFFER_RW(Cache,
    uint hash[65536];
    uint age[65536];
    uint candidates_count[65536];
    Reservoir candidates[65536][CACHE_MAX_CANDIDATES];
    Reservoir reservoir[65536];
)

float uint2float(uint x) {
    return float(x)/float(0xFFFFFFFF);
}

bool GetCellIdx(vec3 pos, inout uint idx) {
    vec3 pDiff = abs(pos-GetCameraPosition());
    float dist = max(max(pDiff.x, pDiff.y), pDiff.z);

    float SCALE = 4.0 / max(floor(log(dist)), 0.5);
    uvec3 coord = uvec3(abs(pos-EPS)*SCALE);
    uvec3 id = pcg3d(coord^floatBitsToUint(SCALE));
    idx = id.x&0xFFFF;
    uint hash = id.z;

    // try to find cell
    for(int i = 0; i < 8; i++) {
        uint expected_hash = Cache[RadianceCacheRID].hash[idx+i];
        if(expected_hash == hash) {
            idx += i;
            return true;
        }
    }

    // alloc not found cell
    for(int i = 0; i < 8; i++) {
        if(atomicCompSwap(Cache[RadianceCacheRID].hash[idx+i], 0, hash) == 0) {
            idx += i;
            return true;
        }
    }

    return false;
}

COMPUTE(8, 8, 1)
void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    
    uvec4 gbuffer = GBufferFetch(GBufferRID, pixel);
    if(GBufferGetVisibility(gbuffer) == 0u) {
        return;
    }
    float t = GBufferGetDepth(gbuffer);
    vec3 n = GBufferGetNormal(gbuffer);
    
    vec2 uv = vec2(pixel+GetJitter())*GetiRes();
    vec3 o = GetCameraPosition();
    vec3 d = UVToRayDir(uv);
    
    // Sampler samp;
    // InitSampler(samp, pixel, GetFrame()%64);
    vec3 pos = o + d*t;
    vec3 acc = vec3(0);
    uint idx = 0;
    if(GetCellIdx(pos/*+SampleNoise(samp).xyz*0.5*/, idx)) {
        Cache[RadianceCacheRID].age[idx] = 0;

        ivec2 off = ivec2(OFFSETS[GetFrame()%64]*8);
        if(pixel.x % 8 == off.x && pixel.y % 8 == off.y) {
            GISample s;
            s.xv = pos;
            s.nv = n;

            Sampler samp;
            InitSampler(samp, pixel, GetFrame()%64);
            PathTraceState state;
            InitPathTraceState(state, pos + n*EPS, SampleUniformHemisphere(n, SampleNoise(samp).xy));
            bool hit = PathTraceProceed(state, samp);

            // TODO: Multi bounce
            //if(hit) {
            //    uint bounceIdx = 0;
            //    if(hit && GetCellIdx(state.o, bounceIdx)) {
            //        Reservoir r = Cache[RadianceCacheRID].reservoir[bounceIdx];
            //        Cache[RadianceCacheRID].age[bounceIdx] = 0;
            //        if(r.M > 0.0) {
            //            state.acc += r.s.radiance*r.W* max(0, dot(n, normalize(r.s.xs - r.s.xv)));
            //        }
            //    }
            //}
            
            uint candidate_id = atomicAdd(Cache[RadianceCacheRID].candidates_count[idx], 1);
            if(candidate_id < CACHE_MAX_CANDIDATES) {
                Reservoir r;
                ReservoirClear(r);

                s.xs = state.o;
                s.ns = state.n;
                s.radiance = state.acc;
                float w = length(s.radiance);
                ReservoirUpdate(r, s, w, SampleNoise(samp).x);
                ReservoirFinalize(r);
                Cache[RadianceCacheRID].candidates[idx][candidate_id] = r;
            }
        }
        
        Reservoir r = Cache[RadianceCacheRID].reservoir[idx];
        if(r.M > 0.0) {
            acc = r.s.radiance*r.W;//* max(0, dot(n, normalize(r.s.xs - r.s.xv)));// * max(0, dot(n, normalize(r.s.xs - r.s.xv)));// * r.W;
        } else {
            acc = vec3(0,0,1); // Reservoir is empty
        }
    } else {
        acc = vec3(1,0,0); // Failed to find/allocate cell
    }
    // acc = RandomColor(idx);
    
    imageStore(Image2DW[ColorTextureRID], pixel, vec4(acc,1));
}