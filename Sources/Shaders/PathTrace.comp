#include "Common.frag"

PUSH(
    int ColorTextureRID;
    int NormalTextureRID;
    int VisibilityTextureRID;
    int DepthTextureRID;
    int _ViewBufferRID;
    int TLASRID;
    int VoxInstancesRID;
)

#define IMPORT
#include "View.frag"
#include "Light.frag"

const vec2 OFFSETS[16] = {
    vec2(0.5000, 0.3333),
    vec2(0.2500, 0.6667),
    vec2(0.7500, 0.1111),
    vec2(0.1250, 0.4444),
    vec2(0.6250, 0.7778),
    vec2(0.3750, 0.2222),
    vec2(0.8750, 0.5556),
    vec2(0.0625, 0.8889),
    vec2(0.5625, 0.0370),
    vec2(0.3125, 0.3704),
    vec2(0.8125, 0.7037),
    vec2(0.1875, 0.1481),
    vec2(0.6875, 0.4815),
    vec2(0.4375, 0.8148),
    vec2(0.9375, 0.2593),
    vec2(0.0313, 0.5926)
};
struct Sampler {
    ivec2 pixel;
    int frame;
    int depth;
};

void InitSampler(inout Sampler samp, ivec2 pixel, int frame) {
    samp.pixel = pixel;
    samp.frame = frame;
    samp.depth = 0;
}
#define BLUE_NOISE (Sampler2D[ViewBuffer[_ViewBufferRID].BlueNoiseRID])
vec4 SampleNoise(inout Sampler samp) {
    vec2 res = textureSize(BLUE_NOISE, 0);
    samp.depth++;
    //return texelFetch(BLUE_NOISE, ivec2((vec2(samp.pixel)+vec2(GOLDEN_RATIO*(mod(samp.frame+samp.depth*5,64)), GOLDEN_RATIO*(mod(samp.frame+samp.depth*7+1,64))))*res)%512, 0).r;
    return texelFetch(BLUE_NOISE, (samp.pixel+ivec2(OFFSETS[(samp.frame+samp.depth)%16]*512.0+samp.frame*GOLDEN_RATIO))%512, 0);
}

COMPUTE(8, 8, 1)
void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    vec2 uv = vec2(pixel+GetJitter())*GetiRes();
    vec3 o = GetCameraPosition();
    vec3 d = UVToRayDir(uv);

    vec3 acc = vec3(0);

    uint visibility = texelFetch(USampler2D[VisibilityTextureRID], pixel, 0).x;
    if(visibility == 0u) {
        return;
    }

    float t = texelFetch(Sampler2D[DepthTextureRID], pixel, 0).x;
    vec3 normal = texelFetch(Sampler2D[NormalTextureRID], pixel, 0).xyz;
    vec3 pos = o + d * t;

    Sampler samp;
    InitSampler(samp, ivec2(gl_GlobalInvocationID.xy), GetFrame()%32);
    vec3 throughput = vec3(1.0);

    TraceHit hit;
    hit.t = t;
    hit.normal = normal;
    hit.visibility = visibility;
    for(int depth = 0; depth < 4; depth++) {
        o = o + d*hit.t + hit.normal*EPS*max(t, 0.1);
        d = CosineSampleHemisphere(SampleNoise(samp).xy, hit.normal);

        // Sun Light
        vec3 skyDir = normalize(d+vec3(0.3,0.4,0.5)*10.0);
        if(!TraceShadowRay(o, skyDir, INF)) {
           acc += throughput * vec3(0.9,0.9,0.8);
        }

        // Continue Bounces
        if(TraceRay(o, d, INF, hit)){
            vec3 albedo;
            vec3 material;
            GetMaterial(hit.visibility, albedo, material);
            acc += albedo * throughput * material.z * 10.0;

            throughput *= albedo;
        } else {
            acc += GetSkyColor(d) * throughput * 2.0;
            break;
        }
    }
    imageStore(Image2DW[ColorTextureRID], ivec2(gl_GlobalInvocationID.x,gl_GlobalInvocationID.y), vec4(acc,1));
}