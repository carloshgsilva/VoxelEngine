#include "Common.frag"

PUSH(
    int OutRadianceTextureRID;
    int InRadianceTextureRID;
    int GBufferRID;
    int _ViewBufferRID;
)

#define IMPORT
#include "View.frag"
#include "Denoiser.frag"

float CalculateVariance(ivec2 pixel) {
    const float KERNEL[2][2] = {
        {1.0/4.0, 1.0/8.0},
        {1.0/8.0, 1.0/16.0}
    };

    vec3 mean = vec3(0);
    vec3 mean2 = vec3(0);
    const int KernelSize = 2;
    for(int x = -KernelSize; x <= KernelSize; x++) {
        for(int y = -KernelSize; y <= KernelSize; y++) {
            ivec2 nPixel = pixel + ivec2(x, y);
            vec3 nRadiance = texelFetch(Sampler2D[InRadianceTextureRID], nPixel, 0).xyz;
            float k = KERNEL[abs(x)][abs(y)];

            mean += nRadiance * k;
            mean2 += nRadiance * nRadiance * k;
        }
    }

    float meanLum = Luminance(mean);
    return max(Luminance(mean2) - meanLum * meanLum, 0) / ((KernelSize*2+1)*(KernelSize*2+1));
}

COMPUTE(8, 8, 1)
void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    vec2 uv = vec2(pixel)*GetiRes();
    if(uv.x > 1.0 || uv.y > 1.0)return;
    vec3 o = GetCameraPosition();
    vec3 d = UVToRayDir(uv);

    uvec4 gbuffer = GBufferFetch(GBufferRID, pixel);
    if(GBufferGetVisibility(gbuffer) == 0u) {
        return;
    }
    float t = GBufferGetDepth(gbuffer);
    vec3 normal = GBufferGetNormal(gbuffer);
    vec3 pos = o + d * t;

    vec4 radianceVar = texelFetch(Sampler2D[InRadianceTextureRID], pixel, 0);
    vec3 radiance = radianceVar.xyz;
    float luminance = Luminance(radiance);
    float reactivity = radianceVar.w;
    
    vec3 acc = radiance;
    float total = 1.0;
    float radius = 1.0;
    for (float ang = GetFrame(); radius <= (reactivity > 0.01 ? 8.0 : 2.0); ang += GOLDEN_ANGLE) {
        radius += 1.0/radius;
        
        ivec2 nPixel = pixel + ivec2(vec2(cos(ang), sin(ang)) * radius * 2);
        if(nPixel == pixel) continue;

        uvec4 nGBuffer = GBufferFetch(GBufferRID, nPixel);
        vec2 nUV = vec2(nPixel)*GetiRes();
        vec3 nDir = UVToRayDir(nUV);
        float nT = GBufferGetDepth(nGBuffer);
        vec3 nPos = o + nDir * nT;
        vec3 nRadiance = texelFetch(Sampler2D[InRadianceTextureRID], nPixel, 0).xyz;
        float nLuminance = Luminance(nRadiance);
        vec3 nNormal = GBufferGetNormal(nGBuffer);
        if(dot(nNormal, vec3(1)) == 0.0) {
            continue;
        }
        
        float w = 1.0;
        float luminanceWeight = 0.001*abs(luminance - nLuminance)/max(luminance, 0.001);
        w *= exp(-luminanceWeight*(1.0-reactivity));
        w *= IsInsideScreenWeight(uv);
        w *= NormalWeight(normal, nNormal, nT);
        w *= PlaneWeight(pos, normal, nPos, nT);
        
        acc += w*nRadiance;
        total += w;
    }

    acc /= total;
    #if 0 // debug reactivity
        acc = vec3(reactivity, 0, 0);
    #endif
    imageStore(Image2DW[OutRadianceTextureRID], pixel, vec4(acc, reactivity));
}