#include "Common.frag"

PUSH(
    int ReservoirA0RID;
    int ReservoirA1RID;
    int ReservoirA2RID;
    int ReservoirA3RID;
    int ReservoirB0RID;
    int ReservoirB1RID;
    int ReservoirB2RID;
    int ReservoirB3RID;
    int GBufferRID;
    int PreviousGBufferRID;
    int _ViewBufferRID;
    int TLASRID;
    int VoxInstancesRID;
)

#define IMPORT
#include "View.frag"
#include "Light.frag"
#include "BRDF.frag"
#include "Reservoir.frag"
#include "PathTrace.frag"

ivec2 get_rpx_offset(uint sample_i, uint frame_index) {
    const ivec2 offsets[4] = {
        ivec2(-1, -1),
        ivec2(1, 1),
        ivec2(-1, 1),
        ivec2(1, -1),
    };

    const ivec2 reservoir_px_offset_base = offsets[frame_index & 3] + offsets[(sample_i + (frame_index ^ 1)) & 3];

    return ivec2(reservoir_px_offset_base);
}

ivec2 PermutationSampling(ivec2 pixel, uint rand) {
#if 0
    rand = pcg3d(ivec3(rand)).x;
    ivec2 offset = ivec2(rand & 3, (rand >> 2) & 3);
    pixel += offset;
    pixel.x ^= 3;
    pixel.y ^= 3;
    pixel -= offset;
    return pixel;
#else
    const ivec2 xor_seq[4] = {
        ivec2(3, 3),
        ivec2(2, 1),
        ivec2(1, 2),
        ivec2(3, 3),
    };
    pixel ^= xor_seq[rand&3];
    return pixel;
#endif
}

COMPUTE(8, 8, 1)
void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    vec2 uv = vec2(pixel+GetJitter())*GetiRes();
    vec3 camO = GetCameraPosition();
    vec3 camD = UVToRayDir(uv);

    uvec4 gbuffer = GBufferFetch(GBufferRID, pixel);
    if(GBufferGetVisibility(gbuffer) == 0u) {
        return;
    }
    float t = GBufferGetDepth(gbuffer);
    vec3 n = GBufferGetNormal(gbuffer);

    GISample s;
    s.xv = camO + camD * t + n*EPS*10.0;
    s.nv = n;

    vec2 previousUV = WorldToUVLastView(camO + camD * t);
    ivec2 originPixel = ivec2(previousUV*GetRes());
    ivec2 previousPixel = originPixel;

    Sampler samp;
    InitSampler(samp, pixel, GetFrame()%64);
    bool foundReprojection = false;
    Reservoir previousReservoir;
    ReservoirClear(previousReservoir);

    for(int i = 0; i < 1; i++) {
        if(i == 0) {
            previousPixel = originPixel;
        } else {
            // ivec2 offset = get_rpx_offset(i, GetFrame());
            // previousPixel = originPixel + offset;
            // previousPixel = PermutationSampling(previousPixel, GetFrame()) + offset;
        }

        // geometry validation
        vec2 previousUV = vec2(previousPixel + GetPreviousJitter())*GetiRes();
        uvec4 previousGBuffer = GBufferFetch(PreviousGBufferRID, previousPixel);
        float previousDepth = GBufferGetDepth(previousGBuffer);
        vec3 previousPos = PrevousView_UVDepthToPos(previousUV, previousDepth);

        float planeDist = abs(dot(previousPos - s.xv, n));
        vec3 previousNormal = GBufferGetNormal(previousGBuffer);
        if(planeDist > max(0.0005*t, 0.05) || dot(previousNormal, n) < 0.5 || clamp(previousUV, vec2(0), vec2(1)) != previousUV) {
            continue;
        }

        foundReprojection = true;

        Reservoir reservoir;
        ReservoirLoad(ReservoirB0RID, ReservoirB1RID, ReservoirB2RID, ReservoirB3RID, previousPixel, previousReservoir);
        // float jacobian = 1.0;
        // float pHat = length(reservoir.s.radiance) / jacobian;
        // ReservoirMerge(previousReservoir, reservoir, pHat, SampleNoise(samp).x);
    }
    if(foundReprojection == false || isnan(previousReservoir.w) || isnan(previousReservoir.M) || isnan(previousReservoir.w)) {
        ReservoirClear(previousReservoir);
    }
    
    if(GetFrame()%4 == 0 && previousReservoir.M > 0){ // Radiance validation (only if there's sample in the reservoir)
        vec3 dir = normalize(previousReservoir.s.xs - previousReservoir.s.xv);
        PathTraceState state;
        InitPathTraceState(state, s.xv + s.nv*EPS, dir);
        // Sampler samp;
        InitSampler(samp, pixel, GetFrame()%64);
        PathTraceProceed(state, samp);
        float f = abs(Luminance(previousReservoir.s.radiance) - Luminance(state.acc));

        float newPHat = length(state.acc);
        float oldPHat = length(previousReservoir.s.radiance);
        if(oldPHat > 0.01) {
            // Assumes that all weights feed to the reservoir changes equally
            previousReservoir.w *= newPHat/oldPHat;
            previousReservoir.s.radiance = state.acc;
            previousReservoir.s.xs = state.o;
            previousReservoir.s.ns = state.n;
        }
        // if(newPHat == 0.0) {
        //     previousReservoir.s.radiance = vec3(0,10,0);
        // }
    } else {
        // Sampler samp;
        InitSampler(samp, pixel, GetFrame()%64);
        PathTraceState state;
        InitPathTraceState(state, s.xv, SampleUniformHemisphere(s.nv, SampleNoise(samp).xy));
        PathTraceProceed(state, samp);

        s.xs = state.o;
        s.ns = state.n;
        s.radiance = state.acc;
        
        float w = length(s.radiance);
        ReservoirUpdate(previousReservoir, s, w, SampleNoise(samp).x);
    }
    ReservoirClamp(previousReservoir, 1, 10.0);
    ReservoirFinalize(previousReservoir);
    ReservoirStore(ReservoirA0RID, ReservoirA1RID, ReservoirA2RID, ReservoirA3RID, pixel, previousReservoir);
}