#include "Common.frag"

PUSH(
    int OutRadianceTextureRID;
    int InRadianceTextureRID;
    int GBufferRID;
    int _ViewBufferRID;
    int Size;
)

#define IMPORT
#include "View.frag"
#include "Denoiser.frag"

// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
vec3 SpecularDominantDirection(vec3 n, vec3 v, float roughness) {
    vec3 r = reflect(-v, n);
    float f = (1.0 - roughness) * (sqrt(1.0 - roughness) + roughness);
    return normalize(mix(n, r, f));
}
// Get tangent vectors for the basis for specular filtering.
// Based on "Fast Denoising with Self Stabilizing Recurrent Blurs" by Dmitry Zhdan
void GetSpecularFilterKernelBasis(vec3 v, vec3 n, float roughness, float scale, out vec3 t1, out vec3 t2) {
    vec3 dominant = SpecularDominantDirection(n, v, roughness);
    vec3 reflected = reflect(-dominant, n);

    t1 = normalize(cross(n, reflected)) * scale;
    t2 = cross(reflected, t1);
}

COMPUTE(8, 8, 1)
void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    vec2 uv = vec2(pixel)*GetiRes();
    if(uv.x > 1.0 || uv.y > 1.0)return;
    vec3 o = GetCameraPosition();
    vec3 d = UVToRayDir(uv);

    uvec4 gbuffer = GBufferFetch(GBufferRID, pixel);
    if(GBufferGetVisibility(gbuffer) == 0u) {
        return;
    }
    float t = GBufferGetDepth(gbuffer);
    vec3 normal = GBufferGetNormal(gbuffer);
    vec3 pos = o + d * t;

    vec4 radianceVar = texelFetch(Sampler2D[InRadianceTextureRID], pixel, 0);
    vec3 radiance = radianceVar.xyz;
    float luminance = Luminance(radiance);
    float variance = radianceVar.w;
    float phi = max(1e-4, sqrt(variance));
    
    float w0 = 1.0;//max(exp(-pow(variance/luminance, 2.0)*500.0), 0.1); // the more variance less we need the center pixel to contribute
    vec3 acc = radiance*w0;
    float mean1 = Luminance(acc);
    float mean2 = Luminance(acc)*Luminance(acc);
    float total = w0;
    float radius = 1.0;
    vec2 offset = texelFetch(Sampler2D[ViewBuffer[_ViewBufferRID].BlueNoiseRID], (pixel+GetFrame()*10)%512, 0).xy*2.0 - 1.0;
    for (float ang = GetFrame()*0; radius <= float(8); ang += GOLDEN_ANGLE) {
        radius += 1.0;
        vec3 t1, t2;
        GetSpecularFilterKernelBasis(d, normal, 0.0, t, t1, t2);

        vec3 nLobePos = pos + (t1*(cos(ang)+offset.x)*0.5 + t2*(sin(ang)+offset.y))*radius*0.003*max(variance, 0.4);

        vec2 nUV = WorldToUV(nLobePos);
        ivec2 nPixel = ivec2(nUV*GetRes() + offset);

        uvec4 nGBuffer = GBufferFetch(GBufferRID, nPixel);
        vec3 nDir = UVToRayDir(nUV);
        float nT = GBufferGetDepth(nGBuffer);
        vec3 nPos = o + nDir * nT;
        vec3 nRadiance = texelFetch(Sampler2D[InRadianceTextureRID], nPixel, 0).xyz;
        float nLuminance = Luminance(nRadiance);
        vec3 nNormal = GBufferGetNormal(nGBuffer);
        
        const float GAUSSIAN[2] = {0.44198, 0.27901};
        float w = 1.0;//GAUSSIAN[abs(x)] * GAUSSIAN[abs(y)];
        float luminanceWeight = 1.0*pow(Size, 4.0)*min(abs(luminance - nLuminance) / phi, 100000.0);
        // w *= exp(-luminanceWeight);
        w *= IsInsideScreenWeight(uv);
        w *= NormalWeight(normal, nNormal, nT);
        w *= PlaneWeight(pos, normal, nPos, nT);

        acc += w*nRadiance;
        mean1 += w*nLuminance;
        mean2 += w*nLuminance*nLuminance;
        total += w;
    }
    float newVariance = max(mean2 - mean1*mean1, 0.0); 
    newVariance /= total;

    acc /= total;
    // acc = vec3(variance, 0, 0);
    imageStore(Image2DW[OutRadianceTextureRID], pixel, vec4(acc, variance));
}