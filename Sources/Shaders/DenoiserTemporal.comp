#include "Common.frag"

PUSH(
    int OutRadianceTextureRID;
    int InRadianceTextureRID;
    int InLastRadianceTextureRID;
    int MotionTextureRID;
    int GBufferRID;
    int PreviousGBufferRID;
    int _ViewBufferRID;
)

#define IMPORT
#include "View.frag"
#include "Denoiser.frag"

float GetReprojectionWeight(ivec2 previousPixel, vec3 pos, vec3 n, float depth) {
    uvec4 pGBuffer = GBufferFetch(PreviousGBufferRID, previousPixel);
    vec3 pNormal = GBufferGetNormal(pGBuffer);
    float pDepth = GBufferGetDepth(pGBuffer);
    vec3 pPos = PrevousView_UVDepthToPos(vec2(previousPixel + GetPreviousJitter())*GetiRes(), pDepth);
    return NormalWeight(pNormal, n, depth) * PlaneWeight(pos, n, pPos, depth) * IsInsideScreenWeight(vec2(previousPixel)*GetiRes());
}

vec4 GeometryAwareBilinearReprojection(vec2 previousUV, vec3 pos, vec3 n, float depth, inout bool failed) {
    vec2 previousPixelFloat = previousUV*GetRes() - 0.5;
    vec2 t1 = fract(previousPixelFloat);
    vec2 t0 = vec2(1) - t1;
    ivec2 previousPixel = ivec2(previousPixelFloat);

    float w00 = t0.x*t0.y * GetReprojectionWeight(previousPixel + ivec2(0, 0), pos, n, depth);
    float w01 = t0.x*t1.y * GetReprojectionWeight(previousPixel + ivec2(0, 1), pos, n, depth);
    float w10 = t1.x*t0.y * GetReprojectionWeight(previousPixel + ivec2(1, 0), pos, n, depth);
    float w11 = t1.x*t1.y * GetReprojectionWeight(previousPixel + ivec2(1, 1), pos, n, depth);

    vec4 r00 = texelFetch(Sampler2D[InLastRadianceTextureRID], previousPixel + ivec2(0, 0), 0);
    vec4 r01 = texelFetch(Sampler2D[InLastRadianceTextureRID], previousPixel + ivec2(0, 1), 0);
    vec4 r10 = texelFetch(Sampler2D[InLastRadianceTextureRID], previousPixel + ivec2(1, 0), 0);
    vec4 r11 = texelFetch(Sampler2D[InLastRadianceTextureRID], previousPixel + ivec2(1, 1), 0);

    float totalWeight = w00 + w01 + w10 + w11;
    if(totalWeight < 1.0e-6) {
        failed = true;
        //return vec3(100,0,0); // Red debug reprojection fail
        totalWeight = 1.0;
    }
    return (r00*w00 + r01*w01 + r10*w10 + r11*w11) / totalWeight;
}

COMPUTE(8, 8, 1)
void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    vec2 uv = vec2(pixel + GetJitter())*GetiRes();
    vec3 o = GetCameraPosition();
    vec3 d = UVToRayDir(uv);

    uvec4 gbuffer = GBufferFetch(GBufferRID, pixel);
    if(GBufferGetVisibility(gbuffer) == 0u) {
        return;
    }
    float t = GBufferGetDepth(gbuffer);
    vec3 n = GBufferGetNormal(gbuffer);
    vec3 pos = o + d * t;

    
    vec2 previousUV = WorldToUVLastView(pos) - (GetPreviousJitter() - 0.5)*GetiRes();// - GetJitter()*GetiRes();;// + (GetPreviousJitter() - 0.5)*GetiRes();//+ 0.5*GetiRes();
    bool reprojectionFailed = false;
    //vec4 previousRadianceVariance = texture(Sampler2D[InLastRadianceTextureRID], previousUV);
    vec4 previousRadianceReact = GeometryAwareBilinearReprojection(previousUV, pos, n, t, reprojectionFailed);

    vec4 radianceReact = texelFetch(Sampler2D[InRadianceTextureRID], pixel, 0);
    vec3 radiance = radianceReact.xyz;
    float reactivity = max(previousRadianceReact.w - 0.05 , 0);

    if(clamp(previousUV, 0.0, 1.0) != previousUV || reprojectionFailed) {
        previousRadianceReact.xyz = radiance;
        reactivity = 1.0;
    }

    if(radianceReact.w < 0.0001) {
        // reactivity = 1.0;
    }
    
    // radiance = mix(radiance, previousRadianceReact.xyz, 0.9 * clamp(1.0 - previousRadianceReact.w, 0, 1));
    imageStore(Image2DW[OutRadianceTextureRID], pixel, vec4(radiance, reactivity));
}