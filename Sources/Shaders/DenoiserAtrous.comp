#include "Common.frag"

PUSH(
    int OutRadianceTextureRID;
    int InRadianceTextureRID;
    int GBufferRID;
    int _ViewBufferRID;
    int Size;
)

#define IMPORT
#include "View.frag"
#include "Denoiser.frag"

float CalculateVariance(ivec2 pixel) {
    const float KERNEL[2][2] = {
        {1.0/4.0, 1.0/8.0},
        {1.0/8.0, 1.0/16.0}
    };

    vec3 mean = vec3(0);
    vec3 mean2 = vec3(0);
    const int KernelSize = 2;
    for(int x = -KernelSize; x <= KernelSize; x++) {
        for(int y = -KernelSize; y <= KernelSize; y++) {
            ivec2 nPixel = pixel + ivec2(x, y);
            vec3 nRadiance = texelFetch(Sampler2D[InRadianceTextureRID], nPixel, 0).xyz;
            float k = KERNEL[abs(x)][abs(y)];

            mean += nRadiance * k;
            mean2 += nRadiance * nRadiance * k;
        }
    }

    float meanLum = Luminance(mean);
    return max(Luminance(mean2) - meanLum * meanLum, 0) / ((KernelSize*2+1)*(KernelSize*2+1));
}

COMPUTE(8, 8, 1)
void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    vec2 uv = vec2(pixel)*GetiRes();
    if(uv.x > 1.0 || uv.y > 1.0)return;
    vec3 o = GetCameraPosition();
    vec3 d = UVToRayDir(uv);

    uvec4 gbuffer = GBufferFetch(GBufferRID, pixel);
    if(GBufferGetVisibility(gbuffer) == 0u) {
        return;
    }
    float t = GBufferGetDepth(gbuffer);
    vec3 normal = GBufferGetNormal(gbuffer);
    vec3 pos = o + d * t;

    vec4 radianceVar = texelFetch(Sampler2D[InRadianceTextureRID], pixel, 0);
    vec3 radiance = radianceVar.xyz;
    float luminance = Luminance(radiance);
    float variance = max(radianceVar.w, 0.3);
    float phi = max(1e-4, sqrt(variance));
    
    float w0 = max(exp(-pow(variance/luminance, 2.0)*500.0), 0.1); // the more variance less we need the center pixel to contribute
    vec3 acc = radiance*w0;
    float mean1 = Luminance(acc);
    float mean2 = Luminance(acc)*Luminance(acc);
    float total = w0;
    for(int x = -1; x <= 1; x++) {
        for(int y = -1; y <= 1; y++) {
            if(x == 0 && y == 0) continue;
            ivec2 offset = ivec2(x, y)*Size;
            ivec2 nPixel = pixel + offset;

            uvec4 nGBuffer = GBufferFetch(GBufferRID, nPixel);
            vec2 nUV = vec2(nPixel)*GetiRes();
            vec3 nDir = UVToRayDir(nUV);
            float nT = GBufferGetDepth(nGBuffer);
            vec3 nPos = o + nDir * nT;
            vec3 nRadiance = texelFetch(Sampler2D[InRadianceTextureRID], nPixel, 0).xyz;
            float nLuminance = Luminance(nRadiance);

            vec3 nNormal = GBufferGetNormal(nGBuffer);
            
            const float GAUSSIAN[2] = {0.44198, 0.27901};
            float w = GAUSSIAN[abs(x)] * GAUSSIAN[abs(y)];
            float luminanceWeight = 0.05*variance*pow(Size, 4.0)*min(abs(luminance - nLuminance) / phi, abs(luminance - nLuminance)/max(luminance, 0.001));
            // w *= exp(-luminanceWeight);
            w *= IsInsideScreenWeight(uv);
            w *= NormalWeight(normal, nNormal, nT);
            w *= PlaneWeight(pos, normal, nPos, nT);

            acc += w*nRadiance;
            mean1 += w*nLuminance;
            mean2 += w*nLuminance*nLuminance;
            total += w;
        }
    }
    float newVariance = max(mean2 - mean1*mean1, 0.0); 
    newVariance /= total;

    acc /= total;
    imageStore(Image2DW[OutRadianceTextureRID], pixel, vec4(acc, (Size == 1) ? variance : newVariance));
}